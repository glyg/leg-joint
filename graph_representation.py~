#!/usr/bin/env python
# -*- coding: utf-8 -*-


import numpy as np
from numpy.random import normal, random_sample

import graph_tool as gt
from graph_tool.generation import geometric_graph
from graph_tool.draw import graph_draw

import pylab as plt
from mpl_toolkits.mplot3d import Axes3D

def compute_vertices_coordinates(rho_0=60., rho_noise=0.01, lambda_avg=6.):

    surface = 8 * np.pi * rho_0**2
    num_vertices = np.int(surface / (lambda_avg**2))
    
    rhos_body = normal(rho_0, rho_noise, num_vertices // 2)
    thetas_body = random_sample(num_vertices // 2) * 2 * np.pi - np.pi
    zeds_body = random_sample(num_vertices // 2)  * 2 * rho_0 - rho_0
    rtz_body = rhos_body, thetas_body, zeds_body

    rhos_capA = normal(rho_0, rho_noise, num_vertices // 4)
    thetas_capA = random_sample(num_vertices // 4) * 2 * np.pi - np.pi
    zeds_capA =  - rho_0 * (random_sample(num_vertices // 4) + 1)
    rtz_capA = rhos_capA, thetas_capA, zeds_capA

    thetas_capB = random_sample(num_vertices // 4) * 2 * np.pi - np.pi
    rhos_capB = normal(rho_0, rho_noise, num_vertices // 4)
    zeds_capB = rho_0 * (random_sample(num_vertices // 4) + 1)
    rtz_capB = rhos_capB, thetas_capB, zeds_capB
    
    return rtz_body, rtz_capA, rtz_capB
    

def cylindrical2cartesian(rtz):
    """
    Transforms cylindrical coordinates ::math:(\rho, \theta, z)
    into cartesian ::math:(x, y, z).
    """
    rho, theta, zed = rtz
    xs = rho * np.cos(theta)
    ys = rho * np.sin(theta)
    return xs, ys, zed

def vertices_scatterplot(rtz_body, rtz_capA, rtz_capB):

    xyz_body = cylindrical2cartesian(rtz_body)
    xyz_capA = cylindrical2cartesian(rtz_capA)
    xyz_capB = cylindrical2cartesian(rtz_capB)
    
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(xyz_body, 'ro')
    ax.scatter(xyz_capA, 'ro')
    ax.scatter(xyz_capB, 'ro')
    pl.show
